---
title: "Ferring Data Browser 2.0 Dev Documentation"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## General Structure

The structure of the FDB2.0 consists of a central `app.R` and multiple modules to explore data with, each created with three main files, an UI file, a Server file, and a Functions file.

When creating a new module, define the layout of the UI elements of the module in the UI file, define what user actions do (such as what happens when a button is pressed) in the Server file, and define any extra functions that may be neccessary (such as calculation functions) in the Functions file. FDB2.0 uses separate namespaces for each module, so shared variable names across modules should not cause issues.

## `app.R`

As FDB2.0 uses R Shiny as a base, the general structure of Shiny apps apply to FDB2.0. FDB2.0 uses the [single file format](https://shiny.rstudio.com/articles/app-formats.html), so `ui.R` and `server.R` are both defined in `app.R`.

Here is the general structure for FDB2.0's `app.R`.

- Library Import
- Module Import
- UI
  - Sidebar
  - Body
- Server
  - Module Server Functions

The **Library Import** section is where all necessary libraries will be imported. Any library used in any other file in FDB2.0 can be imported here. 

The **Module Import** section is where all FDB2.0 modules will be imported. All three files for each module must be imported:
```
source("xxx_functions.R")
source("xxx_ui.R")
source("xxx_server.R")
```

The **UI** section consists of two main subsections, `dashboardSidebar` and `dashboardBody`. 

In `dashboardSidebar`, define the name of the module as well as the tab ID. It also sets the [icon](https://shiny.rstudio.com/reference/shiny/0.14/icon.html) of the tab.
```
dashboardSidebar(sidebarMenu(
    menuItem("Module 1", tabName = "module1", icon = icon("chart-bar")),
    menuItem("Module 2", tabName = "module2", icon = icon("chart-area"))
  )),
```

In `dashboardBody`, specify the UI to accompany each tab. The tab ID must match the ID specified in `dashboardSidebar` and must be unique across all modules, as this ID is also used to create the namespace for each module.
```
dashboardBody(tabItems(
    module1UI("module1"),
    module2UI("module2")
  ))
```

The **Server** is a simple section that just runs the server functions for each module. Again, the ID must match the UI and namespace ID.
```
server <- function(input, output, session) {
  module1Server("module1")
  module2Server("module2")
}
```

## UI File

Each `xxx_ui.R` file consists of a single function, `xxxUI`. The function creates the namespace and defines the UI layout of the input and output of the module.

```
module1UI <- function(id) {
  ns <- NS(id)    #Create the namespace with ID. (IMPORTANT)
  tabItem(
    tabName = "module1",    #tabName must match ID
    h2("Module 1"),
    fluidRow(
      box(
        title = "Input",
        tabsetPanel(
          id = ns("dataInput"),
          tabPanel(
            "Data",
            numericInput(ns("x"), "X", value = 1, min = 1),
            actionButton(ns("continue"), label = "Use these Files"),
            uiOutput(ns("y")),
            uiOutput(ns("z")),
            uiOutput(ns("submit"))
          )
        )
      ),
      box(
        title = "Output",
        textOutput(ns("solution"))
      )
    )
  )
}
```

The elements inside `tabPanel` are the inputs for the user, a list of which can be seen [here](https://shiny.rstudio.com/tutorial/written-tutorial/lesson3/). Any Shiny inputs can be used in this section.


The `uiOutput` elements are placeholders for future UI elements after some action is taken by the user. For example, if the selection list for Y cannot be known until the user uploads a file, Y can be hidden until the user clicks the `continue` button after uploading a file. The elements that replace each `uiOutput` is defined in the Server file, along with the actions that trigger the change of each `uiOutput` to an actual UI element.

The `box` section at the bottom defines the output of the module, an assortment of which can be seen [here](https://shiny.rstudio.com/tutorial/written-tutorial/lesson4/).

## Server File

The `xxx_server.R` file defines the actions of the module as the user changes and creates inputs. The main function used in the Server file is `observeEvent`, which detects changes in the UI and runs the code within once detected. In FDB2.0, this is mainly used to detect when an `actionButton` is clicked.

The general structure of a Server file is shown below. The first line must match the function name used in `app.R`, but apart from that nothing needs to be touched until the `ns <- NS(id)` line. The `observeEvent` blocks can be stacked as needed. In this example, the app has two buttons, a `continue` button and a `submit`.

```
module1Server <- function(id) {
  moduleServer(
    id,
    function(input, output, session) {
      ns <- NS(id)
      #Start editing here.
      observeEvent(
        eventExpr = input$continue,
        handlerExpr = {
          #Code to run when the continue button is pressed goes here.
        }
      )
      observeEvent(
        eventExpr = input$submit,
        handlerExpr = {
          #Code to run when the submit button is pressed goes here.
        }
      )
      #End editing here.
    }
  )
}
```

Normal R code can be ran inside `handlerExpr`, and user input can be accessed by using `input$`.
```
observeEvent(
  eventExpr = input$continue,
  handlerExpr = {
    firstNum <- input$x
    output$y <- renderUI({
      numericInput(ns("y"), "Y", value = firstNum + 1)
    })
    output$z <- renderUI({
      numericInput(ns("z"), "Z", value = 3)
    })
    output$submit <- renderUI({
      actionButton(ns("submit"), label = "Submit")
    })
  }
)
```

The `output$xxx <- renderUI` connects to the `uiOutput` created in the UI file. The inputs within `renderUI` are rendered in each `uiOutput`. This allows for the inputs from the previous UI elements to be accessed to modify the input values of `uiOutput` elements. An example can be seen in the `y` input, which has it's initial value defined by the `x` value inputted by the user. Note that each input element name is surrounded by `ns()`, which defines that variable name within the namespace.

After all user inputs, `observeEvent` can use the functions in the Function file to output something to the user, such as a plot, chart, or just text. Below, `exampleFunction` is defined in the Function file.

```
observeEvent(
        eventExpr = input$submit,
        handlerExpr = {
          output$solution <- renderText(exampleFunction(input$x, input$y, input$z))
        }
      )
```

## Functions file

This is an optional file that contains functions necessary for the evaluation and analysis of data that may be long and unwieldy in the Server file. Note that all these functions can be defined anywhere else in FDB2.0, but are defined here to maintain modularity and code simplicity. A short function can just be defined in the Server file, but defining all non Shiny related functions here can help maintain readability of the overall module.

```
exampleFunction <- function(x, y, z) {
  return(x + y * z)
}
```

One way the Function file can be used is directly porting non Shiny functions previously created into FDB2.0 with minimal issue. Just calling the function with the required inputs and returning the output defined in the UI and Server files will allow any function previously created to be used in FDB2.0.


## Example

A simple working example can be seen in `example_ui.R`, `example_server.R`, and `example_functions.R`.
