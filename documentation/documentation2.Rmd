---
title: "Ferring Data Browser 2.0 Dev Documentation"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## General Structure

FDB2.0 performs two main functions, the "Engine" function, where users can select and upload their own datasets for analysis, and the "Server/JSON" function, where users are sent a URL pointing to a specific configuration JSON that pre-selects the dataset and pre-fills the input fields so that a specific configuration can be shared among users. 

The structure of the FDB2.0 consists of a central `app.R` and multiple modules to explore data with, each created with three main files, an UI file, a Server file, and a Functions file. When creating a new module, define the layout of the UI elements of the module in the UI file, define what user actions do (such as what happens when a button is pressed) in the Server file, and define any extra functions that may be neccessary (such as calculation functions) in the Functions file. FDB2.0 uses separate namespaces for each module, meaning that each module is isolated from each other. So, shared variable names across modules should not cause any issues if implemented properly.

## `app.R`

`app.R` works as the central hub for FDB2.0. It contains all the library imports, defines the modules to be used in FDB, and initializes the Shiny server. As FDB2.0 uses R Shiny as a base, the general structure of Shiny apps apply to FDB2.0. FDB2.0 uses the [single file format](https://shiny.rstudio.com/articles/app-formats.html), so `ui.R` and `server.R` are both defined in `app.R`.

In general, when new modules are created, it takes little change to implement it into FDB2.0. Here are the list of elements to include.

1) The three files that define the module. Imported near the top of `app.R`.
```
source("x_functions.R")
source("x_ui.R")
source("x_server.R")
```

2) Module tab handle on the right sidebar of FDB2.0 in `sidebarMenu()`.

```
menuItem("ExampleModule", tabName = "examplemodule", icon = icon("pizza-slice"))
```

Note that `tabName` works as a unique ID for the namespace for the module, and MUST be unique from the other modules. Also, this must match exactly (including case) with the `id` values in the server and UI files for each module, explained later in this document. The [icon](https://shiny.rstudio.com/reference/shiny/0.14/icon.html) of the tab is also set here.

3) Module UI in `tabItems()`.

```
examplemoduleUI("examplemodule")
```

The function as defined in the module UI file. Again, the parameter inside the function must match the `tabName` from earlier and must be unique from the other modules.


4) Server/JSON initialization in the `switch()`

```
"examplemodule" = examplemoduleServer("examplemodule", useJson, datapaths, params)
```

The leftmost value must again match the ID used in the other sections of the module. Apart from the ID name ("examplemodule" in this case), and the server function name ("examplemoduleServer), nothing else needs to be changed.

5) Engine initialization in else{}

```

```



## UI File

Each `xxx_ui.R` file consists of a single function, `xxxUI`. The function creates the namespace and defines the UI layout of the input and output of the module.

```
module1UI <- function(id) {
  ns <- NS(id)    #Create the namespace with ID. (IMPORTANT)
  tabItem(
    tabName = "module1",    #tabName must match ID
    h2("Module 1"),
    fluidRow(
      box(
        title = "Input",
        tabsetPanel(
          id = ns("dataInput"),
          tabPanel(
            "Data",
            numericInput(ns("x"), "X", value = 1, min = 1),
            actionButton(ns("continue"), label = "Use these Files"),
            uiOutput(ns("y")),
            uiOutput(ns("z")),
            uiOutput(ns("submit"))
          )
        )
      ),
      box(
        title = "Output",
        textOutput(ns("solution"))
      )
    )
  )
}
```

The elements inside `tabPanel` are the inputs for the user, a list of which can be seen [here](https://shiny.rstudio.com/tutorial/written-tutorial/lesson3/). Any Shiny inputs can be used in this section.


The `uiOutput` elements are placeholders for future UI elements after some action is taken by the user. For example, if the selection list for Y cannot be known until the user uploads a file, Y can be hidden until the user clicks the `continue` button after uploading a file. The elements that replace each `uiOutput` is defined in the Server file, along with the actions that trigger the change of each `uiOutput` to an actual UI element.

The `box` section at the bottom defines the output of the module, an assortment of which can be seen [here](https://shiny.rstudio.com/tutorial/written-tutorial/lesson4/).

## Server File

The `xxx_server.R` file defines the actions of the module as the user changes and creates inputs. The main function used in the Server file is `observeEvent`, which detects changes in the UI and runs the code within once detected. In FDB2.0, this is mainly used to detect when an `actionButton` is clicked.

The general structure of a Server file is shown below. The first line must match the function name used in `app.R`, but apart from that nothing needs to be touched until the `ns <- NS(id)` line. The `observeEvent` blocks can be stacked as needed. In this example, the app has two buttons, a `continue` button and a `submit`.

```
module1Server <- function(id) {
  moduleServer(
    id,
    function(input, output, session) {
      ns <- NS(id)
      #Start editing here.
      observeEvent(
        eventExpr = input$continue,
        handlerExpr = {
          #Code to run when the continue button is pressed goes here.
        }
      )
      observeEvent(
        eventExpr = input$submit,
        handlerExpr = {
          #Code to run when the submit button is pressed goes here.
        }
      )
      #End editing here.
    }
  )
}
```

Normal R code can be ran inside `handlerExpr`, and user input can be accessed by using `input$`.
```
observeEvent(
  eventExpr = input$continue,
  handlerExpr = {
    firstNum <- input$x
    output$y <- renderUI({
      numericInput(ns("y"), "Y", value = firstNum + 1)
    })
    output$z <- renderUI({
      numericInput(ns("z"), "Z", value = 3)
    })
    output$submit <- renderUI({
      actionButton(ns("submit"), label = "Submit")
    })
  }
)
```

The `output$xxx <- renderUI` connects to the `uiOutput` created in the UI file. The inputs within `renderUI` are rendered in each `uiOutput`. This allows for the inputs from the previous UI elements to be accessed to modify the input values of `uiOutput` elements. An example can be seen in the `y` input, which has it's initial value defined by the `x` value inputted by the user. Note that each input element name is surrounded by `ns()`, which defines that variable name within the namespace.

After all user inputs, `observeEvent` can use the functions in the Function file to output something to the user, such as a plot, chart, or just text. Below, `exampleFunction` is defined in the Function file.

```
observeEvent(
        eventExpr = input$submit,
        handlerExpr = {
          output$solution <- renderText(exampleFunction(input$x, input$y, input$z))
        }
      )
```

## Functions file

This is an optional file that contains functions necessary for the evaluation and analysis of data that may be long and unwieldy in the Server file. Note that all these functions can be defined anywhere else in FDB2.0, but are defined here to maintain modularity and code simplicity. A short function can just be defined in the Server file, but defining all non Shiny related functions here can help maintain readability of the overall module.

```
exampleFunction <- function(x, y, z) {
  return(x + y * z)
}
```

One way the Function file can be used is directly porting non Shiny functions previously created into FDB2.0 with minimal issue. Just calling the function with the required inputs and returning the output defined in the UI and Server files will allow any function previously created to be used in FDB2.0.


## Example

A simple working example can be seen in `example_ui.R`, `example_server.R`, and `example_functions.R`.
